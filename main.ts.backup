import { App, Plugin, PluginSettingTab, Setting, MarkdownView, Notice, Modal, TFile, WorkspaceLeaf, EditorPosition, ItemView } from 'obsidian';

interface OutlinerCardViewSettings {
    defaultIndentationLevel: number;
    showCardTitle: boolean;
    allowEditing: boolean;
    cardTransitionAnimation: boolean;
    showHoverButtons: boolean;
    toggleCardViewHotkey: boolean;
    nextCardHotkey: boolean;
    previousCardHotkey: boolean;
}

const DEFAULT_SETTINGS: OutlinerCardViewSettings = {
    defaultIndentationLevel: 2,
    showCardTitle: true,
    allowEditing: true,
    cardTransitionAnimation: true,
    showHoverButtons: true,
    toggleCardViewHotkey: false,
    nextCardHotkey: false,
    previousCardHotkey: false
}

interface BulletPoint {
    text: string;
    level: number;
    children: BulletPoint[];
    lineStart: number;
    lineEnd: number;
}

export default class OutlinerCardViewPlugin extends Plugin {
    settings: OutlinerCardViewSettings;
    private activeEditor: MarkdownView | null = null;
    private activeLeafChange: any = null;
    private currentHoverIcon: HTMLElement | null = null;
    private currentHoverLineId: string | null = null;
    currentOverlay: HTMLElement | null = null; // Track the current overlay element
    currentCardView: CardView | OverlayCardView | null = null; // Track the current active card view (overlay or normal view)
    private hotkeyHandler: (evt: KeyboardEvent) => void; // Global hotkey handler

    async onload() {
        await this.loadSettings();
        console.log('Loading Outliner Card View Plugin');

        // Register view type
        this.registerView(
            'outliner-card-view',
            (leaf) => new CardView(leaf, this)
        );

        // Setup global hotkey handler to only capture hotkeys when card view is active
        this.hotkeyHandler = (evt: KeyboardEvent) => {
            // Only handle hotkeys if card view is active
            if (!this.currentCardView && !this.getCardView()) {
                return;
            }

            // Check for next card hotkey (Alt+ArrowRight)
            if (evt.key === 'ArrowRight' && evt.altKey && this.settings.nextCardHotkey) {
                this.navigateNextCard();
                evt.preventDefault();
                return;
            }

            // Check for previous card hotkey (Alt+ArrowLeft)
            if (evt.key === 'ArrowLeft' && evt.altKey && this.settings.previousCardHotkey) {
                this.navigatePreviousCard();
                evt.preventDefault();
                return;
            }

            // Check for toggle card view hotkey (Mod+Shift+O)
            if (evt.key === 'o' && evt.shiftKey && (evt.ctrlKey || evt.metaKey) && this.settings.toggleCardViewHotkey) {
                this.toggleCardView();
                evt.preventDefault();
                return;
            }
        };

        // Register the global hotkey handler
        document.addEventListener('keydown', this.hotkeyHandler);

        // Register CSS classes for bullet hover icons
        this.registerDomEvent(document, 'mouseover', (evt: MouseEvent) => {
            if (!this.settings.showHoverButtons) return;

            const target = evt.target as HTMLElement;
            const markdownView = this.app.workspace.getActiveViewOfType(MarkdownView);
            if (!markdownView) return;

            const editor = markdownView.editor;
            const cmEditor = (editor as any).cm; // Access CodeMirror instance
            if (!cmEditor) return;

            const lineElement = target.closest('.cm-line') as HTMLElement;
            if (!lineElement) {
                // If not hovering over a line, do nothing specific here, mouseout will handle cleanup
                return;
            }

            const lineText = lineElement.textContent || '';
            const bulletMatch = lineText.match(/^(\s*)(-|\*|\d+\.)\s/);
            if (!bulletMatch) {
                 // If not a bullet line, do nothing specific here, mouseout will handle cleanup
                return;
            }

            let lineId = lineElement.id;
            if (!lineId) {
                lineId = `outliner-line-${Math.random().toString(36).substr(2, 9)}`;
                lineElement.id = lineId;
            }

            // If icon is already shown for this line, do nothing
            if (this.currentHoverIcon && this.currentHoverLineId === lineId) {
                return;
            }

            // Remove previous icon if it exists and is for a different line
            if (this.currentHoverIcon && this.currentHoverLineId !== lineId) {
                this.currentHoverIcon.remove();
                this.currentHoverIcon = null;
                this.currentHoverLineId = null;
            }

            // Check if an icon for this specific line already exists (e.g. from a quick mouse re-entry)
            // This check is secondary to currentHoverIcon logic but good for robustness
            const existingIconForLine = document.querySelector(`.outliner-bullet-hover-container[data-line-id="${lineId}"]`);
            if (existingIconForLine) {
                this.currentHoverIcon = existingIconForLine as HTMLElement;
                this.currentHoverLineId = lineId;
                return;
            }

            // Get the indentation text to calculate level consistently with parseBulletPoints
            const indentText = bulletMatch[1];
            let indentWidth = 0;
            if (cmEditor && typeof cmEditor.defaultCharacterWidth === 'number') {
                indentWidth = indentText.length * cmEditor.defaultCharacterWidth;
            } else {
                const tempSpan = document.createElement('span');
                tempSpan.style.font = window.getComputedStyle(lineElement).font;
                tempSpan.style.visibility = 'hidden';
                tempSpan.style.position = 'absolute';
                tempSpan.style.whiteSpace = 'pre';
                tempSpan.textContent = indentText;
                document.body.appendChild(tempSpan);
                indentWidth = tempSpan.getBoundingClientRect().width;
                document.body.removeChild(tempSpan);
            }

            // Always use level 2 for the hover icon view
            const finalLevel = 2;

            const iconContainer = document.createElement('div');
            iconContainer.className = 'outliner-bullet-hover-container';
            iconContainer.setAttribute('data-line-id', lineId);
            iconContainer.setAttribute('data-indent-width', indentWidth.toString()); // Store for scroll handler

            const hoverIcon = document.createElement('span');
            hoverIcon.className = 'outliner-bullet-hover-icon';
            hoverIcon.textContent = 'ðŸ”';
            hoverIcon.setAttribute('data-level', finalLevel.toString());
            hoverIcon.title = 'View as cards (level 2)';

            hoverIcon.addEventListener('click', (clickEvt) => {
                clickEvt.preventDefault();
                clickEvt.stopPropagation();

                // Extract relevant info from the current editor state
                const editor = markdownView.editor;
                const lineCount = editor.lineCount();

                // Get the line element corresponding to the hover icon
                const lineElement = document.getElementById(lineId);
                if (!lineElement) return;

                // Find the line number by comparing text content with editor lines
                const lineTextContent = lineElement.textContent || '';
                let targetLine = -1;

                // First, try an exact match based on text content
                for (let i = 0; i < lineCount; i++) {
                    const editorLine = editor.getLine(i);
                    if (editorLine === lineTextContent) {
                        targetLine = i;
                        break;
                    }
                }

                // If exact match failed, try a more flexible match
                if (targetLine === -1) {
                    // Try to match by trimming and using the first part of the line
                    const trimmedContent = lineTextContent.trim();
                    for (let i = 0; i < lineCount; i++) {
                        const editorLine = editor.getLine(i).trim();
                        if (editorLine === trimmedContent ||
                            editorLine.startsWith(trimmedContent.substring(0, Math.min(30, trimmedContent.length)))) {
                            targetLine = i;
                            break;
                        }
                    }
                }

                // If we still couldn't find a match, use the cursor position as fallback
                if (targetLine === -1) {
                    const cursorPos = editor.getCursor();
                    targetLine = cursorPos.line;
                }

                console.log(`Clicked on hover icon for line content: "${lineTextContent.substring(0, 30)}..."`);
                console.log(`Detected line number: ${targetLine}`);

                // Toggle card view with the specified level and navigate to the card for this line
                this.toggleCardViewWithLevel(finalLevel, targetLine);

                if (this.currentHoverIcon) { // Remove icon after click
                    this.currentHoverIcon.remove();
                    this.currentHoverIcon = null;
                    this.currentHoverLineId = null;
                }
            });

            iconContainer.appendChild(hoverIcon);
            document.body.appendChild(iconContainer);

            const rect = lineElement.getBoundingClientRect();
            const iconWidthEst = 20; // Estimated width of the icon container
            const iconGap = 4;    // Gap between icon and bullet

            // Position the icon to the left of the bullet text, not the indentation
            iconContainer.style.top = `${rect.top + window.scrollY}px`;

            // Adjust icon position to place it before the bullet marker regardless of indentation level
            // This ensures icon appears for all indentation levels
            const bulletMarkerPos = indentWidth;
            iconContainer.style.left = `${rect.left + window.scrollX + bulletMarkerPos - iconWidthEst - iconGap}px`;

            this.currentHoverIcon = iconContainer;
            this.currentHoverLineId = lineId;
        });

        this.registerDomEvent(document, 'mouseout', (evt: MouseEvent) => {
            if (!this.settings.showHoverButtons || !this.currentHoverIcon) return;

            const relatedTarget = evt.relatedTarget as HTMLElement;

            // Use a small delay to check if the mouse has moved to the corresponding line or icon
            setTimeout(() => {
                if (!this.currentHoverIcon) return; // Icon might have been removed by another event (e.g. click)

                const isMouseOverIcon = this.currentHoverIcon.matches(':hover');
                const lineElement = this.currentHoverLineId ? document.getElementById(this.currentHoverLineId) : null;
                const isMouseOverLine = lineElement ? lineElement.matches(':hover') : false;

                if (!isMouseOverIcon && !isMouseOverLine) {
                    this.currentHoverIcon.remove();
                    this.currentHoverIcon = null;
                    this.currentHoverLineId = null;
                }
            }, 50); // 50ms delay
        });

        // Add a scroll event listener to reposition hover icons when page scrolls
        this.registerDomEvent(document, 'scroll', () => {
            if (!this.currentHoverIcon || !this.currentHoverLineId) return;

            const lineElement = document.getElementById(this.currentHoverLineId);
            if (lineElement && lineElement.closest('.cm-line')) { // Ensure line is still valid
                const rect = lineElement.getBoundingClientRect();
                const indentWidth = parseFloat(this.currentHoverIcon.getAttribute('data-indent-width') || '0');
                const iconWidthEst = 20;
                const iconGap = 4;

                // Maintain the same positioning logic as in mouseover
                this.currentHoverIcon.style.top = `${rect.top + window.scrollY}px`;

                // Adjust icon position to place it before the bullet marker regardless of indentation level
                const bulletMarkerPos = indentWidth;
                this.currentHoverIcon.style.left = `${rect.left + window.scrollX + bulletMarkerPos - iconWidthEst - iconGap}px`;
            } else {
                // Line not found or no longer valid, remove the icon
                this.currentHoverIcon.remove();
                this.currentHoverIcon = null;
                this.currentHoverLineId = null;
            }
        }, { passive: true });

        // Command to toggle card view
        this.addCommand({
            id: 'toggle-card-view',
            name: 'Toggle Card View',
            callback: () => this.toggleCardView(),
            hotkeys: this.settings.toggleCardViewHotkey ? [
                {
                    modifiers: ["Mod", "Shift"],
                    key: "O"
                }
            ] : []
        });

        // Command to show next card
        this.addCommand({
            id: 'next-card',
            name: 'Show Next Card',
            callback: () => {
                if (!this.navigateNextCard()) {
                    new Notice('Card view is not active');
                }
            },
            hotkeys: this.settings.nextCardHotkey ? [
                {
                    modifiers: ["Alt"],
                    key: "ArrowRight"
                }
            ] : []
        });

        // Command to show previous card
        this.addCommand({
            id: 'previous-card',
            name: 'Show Previous Card',
            callback: () => {
                if (!this.navigatePreviousCard()) {
                    new Notice('Card view is not active');
                }
            },
            hotkeys: this.settings.previousCardHotkey ? [
                {
                    modifiers: ["Alt"],
                    key: "ArrowLeft"
                }
            ] : []
        });

        // Listen for changes in the active leaf
        this.activeLeafChange = this.app.workspace.on('active-leaf-change', (leaf) => {
            // Clean up any existing hover icons first
            this.cleanupHoverIcons();

            const view = leaf?.view;
            if (view instanceof MarkdownView) {
                this.activeEditor = view;
                // Update card view when the active editor changes
                const cardView = this.getCardView();
                if (cardView) {
                    this.updateCardView(cardView);
                }
            }
        });

        // Register event reference
        this.registerEvent(this.activeLeafChange);

        // Add settings tab
        this.addSettingTab(new OutlinerCardViewSettingTab(this.app, this));
    }

    /**
     * Clean up any hover icons when unloading
     */
    private cleanupHoverIcons() {
        // Remove any icon currently tracked
        if (this.currentHoverIcon) {
            this.currentHoverIcon.remove();
            this.currentHoverIcon = null;
            this.currentHoverLineId = null;
        }
        // Fallback: remove any other icons that might have been orphaned
        document.querySelectorAll('.outliner-bullet-hover-container').forEach(container => container.remove());
    }

    /**
     * Clean up any existing overlay
     */
    private cleanupOverlay() {
        // Remove any existing overlay element
        if (this.currentOverlay) {
            this.currentOverlay.remove();
            this.currentOverlay = null;
        }

        // Fallback: remove any other overlays that might have been orphaned
        document.querySelectorAll('#outliner-card-overlay').forEach(overlay => overlay.remove());
    }

    onunload() {
        console.log('Unloading Outliner Card View Plugin');

        // Remove the global hotkey handler
        document.removeEventListener('keydown', this.hotkeyHandler);

        // Clean up any hover icons
        this.cleanupHoverIcons();

        // Clean up any overlay card view
        this.cleanupOverlay();

        // Clean up any card view
        const leaves = this.app.workspace.getLeavesOfType('outliner-card-view');
        leaves.forEach(leaf => leaf.detach());
    }

    /**
     * Gets the active card view (specifically the ItemView implementation)
     * @returns The active card view or null if none is active
     */
    private getCardView(): CardView | null {
        // Only return the regular card view, not the overlay
        const leaves = this.app.workspace.getLeavesOfType('outliner-card-view');
        if (leaves.length === 0) return null;

        const leaf = leaves[0];
        const view = leaf.view;

        if (view instanceof CardView) {
            return view;
        }

        return null;
    }

    /**
     * Toggles the card view overlay
     */
    async toggleCardView() {
        const { workspace } = this.app;

        // Clean up any hover icons
        this.cleanupHoverIcons();

        // Clean up any existing overlay
        this.cleanupOverlay();

        // Check if the view is already visible
        const leaves = workspace.getLeavesOfType('outliner-card-view');

        if (leaves.length > 0) {
            // If the view is open, close it
            leaves.forEach(leaf => leaf.detach());
            return;
        }

        // If not visible, create and display it
        const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
        if (!activeView) {
            new Notice('No active markdown view found.');
            return;
        }

        this.activeEditor = activeView;

        // Create and show overlay directly in the editor
        const overlayEl = document.createElement('div');
        overlayEl.id = 'outliner-card-overlay';
        overlayEl.classList.add('outliner-card-overlay');
        document.body.appendChild(overlayEl);

        // Track the current overlay
        this.currentOverlay = overlayEl;

        // Create the card container within the overlay
        const cardContainer = overlayEl.createEl('div', {
            cls: 'outliner-card-container'
        });

        // Parse the bullet points and create cards
        const editor = this.activeEditor.editor;
        const content = editor.getValue();
        const bulletPoints = this.parseBulletPoints(content);
        const targetLevel = this.settings.defaultIndentationLevel;
        const targetBullets = this.getBulletsAtLevel(bulletPoints, targetLevel);

        if (targetBullets.length === 0) {
            cardContainer.createEl('div', {
                cls: 'outliner-card-empty-state',
                text: 'No bullet points found at the selected indentation level.'
            });

            // Add close button to empty state
            const closeButton = cardContainer.createEl('button', {
                cls: 'outliner-card-navigation-button',
                text: 'Close'
            });
            closeButton.addEventListener('click', () => {
                overlayEl.remove();
                // Clear the reference to the overlay
                this.currentOverlay = null;
            });

            return;
        }

        // Create a simple card view in the overlay
        const cardView = new OverlayCardView(this, overlayEl, cardContainer, targetBullets, this.activeEditor);
        // Store a reference to the active overlay card view
        this.currentCardView = cardView;
        cardView.render();
    }

    /**
     * Toggles the card view overlay with a specific indentation level
     * @param level The indentation level to use for this card view
     * @param lineNumber Optional line number to navigate to the corresponding card
     */
    async toggleCardViewWithLevel(level: number, lineNumber?: number) {
        const { workspace } = this.app;

        // Clean up any hover icons
        this.cleanupHoverIcons();

        // Clean up any existing overlay
        this.cleanupOverlay();

        // Check if the view is already visible
        const leaves = workspace.getLeavesOfType('outliner-card-view');

        if (leaves.length > 0) {
            // If the view is open, close it
            leaves.forEach(leaf => leaf.detach());
            return;
        }

        // If not visible, create and display it
        const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
        if (!activeView) {
            new Notice('No active markdown view found.');
            return;
        }

        this.activeEditor = activeView;

        // Create and show overlay directly in the editor
        const overlayEl = document.createElement('div');
        overlayEl.id = 'outliner-card-overlay';
        overlayEl.classList.add('outliner-card-overlay');
        document.body.appendChild(overlayEl);

        // Track the current overlay
        this.currentOverlay = overlayEl;

        // Create the card container within the overlay
        const cardContainer = overlayEl.createEl('div', {
            cls: 'outliner-card-container'
        });

        // Parse the bullet points and create cards
        const editor = this.activeEditor.editor;
        const content = editor.getValue();
        const bulletPoints = this.parseBulletPoints(content);

        // Optionally log bullet hierarchy for debugging
        console.log(`Parsed bullet hierarchy for level ${level}:`);
        this.logBulletHierarchy(bulletPoints);

        // Use the provided level instead of the default from settings
        const targetBullets = this.getBulletsAtLevel(bulletPoints, level);

        if (targetBullets.length === 0) {
            cardContainer.createEl('div', {
                cls: 'outliner-card-empty-state',
                text: 'No bullet points found at the selected indentation level.'
            });

            // Add close button to empty state
            const closeButton = cardContainer.createEl('button', {
                cls: 'outliner-card-navigation-button',
                text: 'Close'
            });
            closeButton.addEventListener('click', () => {
                overlayEl.remove();
                // Clear the reference to the overlay
                this.currentOverlay = null;
            });

            return;
        }

        // Create a simple card view in the overlay
        const cardView = new OverlayCardView(this, overlayEl, cardContainer, targetBullets, this.activeEditor);
        // Store a reference to the active overlay card view
        this.currentCardView = cardView;

        // If a line number was provided, find the corresponding bullet point
        if (lineNumber !== undefined && lineNumber >= 0) {
            // Find the index of the bullet point that contains the line
            let targetIndex = 0;
            let foundCard = false;

            console.log(`Finding card for line ${lineNumber} among ${targetBullets.length} cards`);

            // First pass: look for exact line range matches
            for (let i = 0; i < targetBullets.length; i++) {
                const bullet = targetBullets[i];
                console.log(`Card ${i}: lines ${bullet.lineStart}-${bullet.lineEnd}, text: "${bullet.text.substring(0, 30)}..."`);

                // Check if the line is within this bullet point's range
                if (lineNumber >= bullet.lineStart && lineNumber <= bullet.lineEnd) {
                    targetIndex = i;
                    foundCard = true;
                    console.log(`Found exact matching card at index ${i}`);
                    break;
                }
            }

            if (!foundCard) {
                // Second pass: If no exact match found, find the closest bullet point before the line
                console.log("No exact match found, searching for closest bullet point");
                let bestMatch = -1;
                let bestDistance = Number.MAX_SAFE_INTEGER;

                // First preference: bullet points before the clicked line
                for (let i = 0; i < targetBullets.length; i++) {
                    const bullet = targetBullets[i];
                    if (bullet.lineStart <= lineNumber) {
                        const distance = lineNumber - bullet.lineStart;
                        if (distance < bestDistance) {
                            bestDistance = distance;
                            bestMatch = i;
                        }
                    }
                }

                // If no bullets found before the line, find closest one after
                if (bestMatch === -1) {
                    bestDistance = Number.MAX_SAFE_INTEGER;
                    for (let i = 0; i < targetBullets.length; i++) {
                        const bullet = targetBullets[i];
                        const distance = bullet.lineStart - lineNumber;
                        if (distance < bestDistance) {
                            bestDistance = distance;
                            bestMatch = i;
                        }
                    }
                }

                if (bestMatch !== -1) {
                    targetIndex = bestMatch;
                    console.log(`Selected closest card at index ${targetIndex}`);
                }
            }

            // Update the view with the specified indentation level
            // Pass false to prevent resetting the card index when changing level
            cardView.refreshWithNewIndentationLevel(level, false);

            // Navigate to the selected card
            cardView.navigateToSpecificCard(targetIndex);
        } else {
            // Update the view with the specified indentation level (and default to first card)
            cardView.refreshWithNewIndentationLevel(level);
        }
    }

    /**
     * Updates the card view with content from the active editor
     */
    updateCardView(cardView: CardView) {
        if (!this.activeEditor) return;

        const editor = this.activeEditor.editor;
        const content = editor.getValue();

        // Parse the bullet points from the content
        const bulletPoints = this.parseBulletPoints(content);

        // Find bullets at the target indentation level
        const targetLevel = this.settings.defaultIndentationLevel;
        const targetBullets = this.getBulletsAtLevel(bulletPoints, targetLevel);

        // Update the card view with the target bullets
        cardView.updateCards(targetBullets, this.activeEditor);
    }    /**
     * Parses bullet points from markdown content using parent-based level assignment
     * @param content The markdown content to parse
     * @returns An array of parsed bullet points
     */
    parseBulletPoints(content: string): BulletPoint[] {
        const lines = content.split('\n');
        const rootBullets: BulletPoint[] = [];
        const stack: BulletPoint[] = [];

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            // Check if this line is a bullet point (starts with -, *, or number followed by period)
            const bulletMatch = line.match(/^(\s*)(-|\*|\d+\.)\s(.*)$/);

            if (bulletMatch) {
                const indent = bulletMatch[1];
                const text = bulletMatch[3].trim();

                // Create new bullet point
                const bulletPoint: BulletPoint = {
                    text,
                    level: 1, // Default to level 1, will be adjusted based on parent
                    children: [],
                    lineStart: i,
                    lineEnd: i
                };

                // If stack is empty, this is a root bullet
                if (stack.length === 0) {
                    rootBullets.push(bulletPoint);
                    stack.push(bulletPoint);
                    continue;
                }

                // Get indentation length of current bullet and last bullet in stack
                const currentIndent = indent.length;
                const lastBullet = stack[stack.length - 1];
                const lastIndentMatch = lines[lastBullet.lineStart].match(/^(\s*)/);
                const lastIndent = lastIndentMatch ? lastIndentMatch[0].length : 0;

                // Compare indentation with last bullet
                if (currentIndent > lastIndent) {
                    // This is a child of the last bullet
                    bulletPoint.level = lastBullet.level + 1;
                    lastBullet.children.push(bulletPoint);
                    stack.push(bulletPoint);
                } else {
                    // Pop stack until we find the right parent or reach root level
                    while (stack.length > 0) {
                        const parentBullet = stack[stack.length - 1];
                        const parentIndentMatch = lines[parentBullet.lineStart].match(/^(\s*)/);
                        const parentIndent = parentIndentMatch ? parentIndentMatch[0].length : 0;

                        if (currentIndent > parentIndent) {
                            // Found the parent
                            bulletPoint.level = parentBullet.level + 1;
                            parentBullet.children.push(bulletPoint);
                            stack.push(bulletPoint);
                            break;
                        }
                        stack.pop();
                    }

                    // If we popped everything, this is a root bullet
                    if (stack.length === 0) {
                        bulletPoint.level = 1;
                        rootBullets.push(bulletPoint);
                        stack.push(bulletPoint);
                    }
                }
            }
            // Handle continuation lines
            else if (stack.length > 0 && line.trim() !== '') {
                const lastBullet = stack[stack.length - 1];
                lastBullet.lineEnd = i;
            }
        }

        return rootBullets;
    }

    /**
     * Gets all bullet points at a specific indentation level
     * @param bullets The array of bullet points to search
     * @param targetLevel The target indentation level
     * @returns An array of bullet points at the target level
     */
    getBulletsAtLevel(bullets: BulletPoint[], targetLevel: number): BulletPoint[] {
        const result: BulletPoint[] = [];

        // Enhanced recursive function to search through the bullet hierarchy
        const findBulletsAtLevel = (bullet: BulletPoint, depth: number = 1) => {
            // Check if this bullet matches the target level
            if (bullet.level === targetLevel) {
                result.push(bullet);
            }
            // Only search children if this bullet could be an ancestor of the target level
            else if (bullet.level < targetLevel) {
                // Continue searching in children
                bullet.children.forEach(child => findBulletsAtLevel(child, depth + 1));
            }
            // Skip branches where the level is already higher than our target
            // This optimization prevents unnecessary traversal
        };

        // Start search from each root bullet
        bullets.forEach(bullet => findBulletsAtLevel(bullet));

        return result;
    }

    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    }

    async saveSettings() {
        await this.saveData(this.settings);
    }

    /**
     * Process basic markdown formatting
     * @param text The text to process
     * @returns Processed HTML with formatting
     */
    processMarkdownFormatting(text: string): string {
        // Process bold text (both **bold** and __bold__ formats)
        let processed = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        processed = processed.replace(/__(.*?)__/g, '<strong>$1</strong>');

        // Process italic text (both *italic* and _italic_ formats)
        processed = processed.replace(/\*([^\*]+)\*/g, '<em>$1</em>');
        processed = processed.replace(/_([^_]+)_/g, '<em>$1</em>');

        // Process code blocks
        processed = processed.replace(/`(.*?)`/g, '<code>$1</code>');

        return processed;
    }

    /**
     * Logs the bullet point hierarchy (for debugging)
     * @param bullets The bullet points to log
     * @param indent The indentation level for the log
     */
    private logBulletHierarchy(bullets: BulletPoint[], indent: string = '') {
        bullets.forEach(bullet => {
            console.log(`${indent}Level ${bullet.level}: ${bullet.text} (Children: ${bullet.children.length})`);
            if (bullet.children.length > 0) {
                this.logBulletHierarchy(bullet.children, indent + '  ');
            }
        });
    }

    /**
     * Navigates to the next card in any active card view
     * @returns true if navigation was successful, false otherwise
     */
    navigateNextCard(): boolean {
        if (this.currentCardView) {
            if (this.currentCardView instanceof OverlayCardView) {
                this.currentCardView.navigateToCard(1);
                return true;
            }
        }

        const cardView = this.getCardView() as CardView;
        if (cardView) {
            cardView.navigateToCard(1);
            return true;
        }

        return false;
    }

    /**
     * Navigates to the previous card in any active card view
     * @returns true if navigation was successful, false otherwise
     */
    navigatePreviousCard(): boolean {
        if (this.currentCardView) {
            if (this.currentCardView instanceof OverlayCardView) {
                this.currentCardView.navigateToCard(-1);
                return true;
            }
        }

        const cardView = this.getCardView() as CardView;
        if (cardView) {
            cardView.navigateToCard(-1);
            return true;
        }

        return false;
    }
}

/**
 * The card view that displays bullet points as cards
 */
class CardView extends ItemView {
    private plugin: OutlinerCardViewPlugin;
    private cards: BulletPoint[] = [];
    private currentCardIndex: number = 0;
    private activeEditor: MarkdownView | null = null;
    private cardViewContent: HTMLElement;
    private escapeHandler: (evt: KeyboardEvent) => void;

    constructor(leaf: WorkspaceLeaf, plugin: OutlinerCardViewPlugin) {
        super(leaf);
        this.plugin = plugin;
        this.cardViewContent = this.containerEl.createDiv('card-view-content');

        // Create escape key handler
        this.escapeHandler = (evt: KeyboardEvent) => {
            if (evt.key === 'Escape') {
                // Close the card view
                const leaves = this.plugin.app.workspace.getLeavesOfType('outliner-card-view');
                leaves.forEach(leaf => leaf.detach());

                // Focus the main editor
                if (this.activeEditor) {
                    this.activeEditor.leaf.view.setEphemeralState({ focus: true });
                }
            }
        };
    }

    /**
     * Updates the view with new cards
     * @param cards The bullet points to display as cards
     * @param editor The active editor view
     */
    updateCards(cards: BulletPoint[], editor: MarkdownView) {
        this.cards = cards;
        this.activeEditor = editor;
        this.currentCardIndex = 0;
        this.render();
    }

    /**
     * Renders the card view
     */
    render() {
        this.cardViewContent.empty();

        if (this.cards.length === 0) {
            this.cardViewContent.createEl('div', {
                cls: 'outliner-card-empty-state',
                text: 'No bullet points found at the selected indentation level.'
            });
            return;
        }

        // Create the card navigation UI
        this.createNavigationUI(this.cardViewContent);

        // Create the card container
        const cardContainer = this.cardViewContent.createEl('div', {
            cls: 'outliner-card-container'
        });

        // Display the current card
        this.displayCard(cardContainer);
    }

    /**
     * Creates the navigation UI for the cards
     * @param contentEl The content element to add the navigation UI to
     */
    createNavigationUI(contentEl: HTMLElement) {
        const navigationContainer = contentEl.createEl('div', {
            cls: 'outliner-card-navigation'
        });

        // Add navigation info
        const navInfo = navigationContainer.createEl('div', {
            cls: 'outliner-card-navigation-info',
            text: `Card ${this.currentCardIndex + 1} of ${this.cards.length}`
        });

        // Add navigation buttons
        const buttonContainer = navigationContainer.createEl('div', {
            cls: 'outliner-card-navigation-buttons'
        });

        // Home/First card button
        const homeButton = buttonContainer.createEl('button', {
            cls: 'outliner-card-navigation-button outliner-card-navigation-home',
            text: 'â®ï¸ First'
        });
        homeButton.addEventListener('click', () => this.navigateToSpecificCard(0));

        // Previous button
        const prevButton = buttonContainer.createEl('button', {
            cls: 'outliner-card-navigation-button',
            text: 'â¬…ï¸ Previous'
        });
        prevButton.addEventListener('click', () => this.navigateToCard(-1));

        // Card selector dropdown
        const selectorContainer = buttonContainer.createEl('div', {
            cls: 'outliner-card-selector-container'
        });

        const selector = selectorContainer.createEl('select', {
            cls: 'outliner-card-selector'
        });

        // Add options for each card
        this.cards.forEach((card, index) => {
            const option = selector.createEl('option', {
                value: index.toString()
            });

            // Create a temporary div to process markdown and get plain text
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = this.processMarkdownFormatting(card.text);
            // Get text content strips HTML tags but preserves emojis
            option.text = tempDiv.textContent || card.text;

            if (index === this.currentCardIndex) {
                option.selected = true;
            }
        });

        selector.addEventListener('change', (e) => {
            const target = e.target as HTMLSelectElement;
            const index = parseInt(target.value);
            this.currentCardIndex = index;
            this.render();
        });

        // Next button
        const nextButton = buttonContainer.createEl('button', {
            cls: 'outliner-card-navigation-button',
            text: 'Next âž¡ï¸'
        });
        nextButton.addEventListener('click', () => this.navigateToCard(1));

        // Last card button
        const lastButton = buttonContainer.createEl('button', {
            cls: 'outliner-card-navigation-button outliner-card-navigation-last',
            text: 'Last â­ï¸'
        });
        lastButton.addEventListener('click', () => this.navigateToSpecificCard(this.cards.length - 1));
    }

    /**
     * Displays the current card
     * @param container The container element to add the card to
     */
    displayCard(container: HTMLElement) {
        const currentCard = this.cards[this.currentCardIndex];
        if (!currentCard) return;

        // Create card title
        if (this.plugin.settings.showCardTitle) {
            const cardTitle = container.createEl('div', {
                cls: 'outliner-card-title'
            });
            // Add formatted title text
            cardTitle.innerHTML = this.processMarkdownFormatting(currentCard.text);
        }

        // Create card content
        const cardContent = container.createEl('div', {
            cls: 'outliner-card-content'
        });

        // Display the card's children as a nested list
        this.renderNestedList(cardContent, currentCard.children);

        // Add edit button if editing is allowed
        if (this.plugin.settings.allowEditing && this.activeEditor) {
            const editButton = container.createEl('button', {
                cls: 'outliner-card-edit-button',
                text: 'Edit Card Content'
            });

            editButton.addEventListener('click', () => this.editCardContent(currentCard));
        }

        // Add transition animations if enabled
        if (this.plugin.settings.cardTransitionAnimation) {
            container.addClass('animate');
        }
    }

    /**
     * Renders a nested list of bullet points
     * @param container The container element to add the list to
     * @param bullets The bullet points to render
     */
    renderNestedList(container: HTMLElement, bullets: BulletPoint[]) {
        if (bullets.length === 0) {
            container.createEl('div', {
                cls: 'outliner-card-empty-content',
                text: 'No content'
            });
            return;
        }

        const list = container.createEl('ul', {
            cls: 'outliner-card-list'
        });

        // Render each bullet point
        bullets.forEach(bullet => {
            const listItem = list.createEl('li', {
                cls: 'outliner-card-list-item'
            });

            // Add the bullet text
            this.renderFormattedBulletText(listItem, bullet.text);

            // If there are children, add a class to the parent for styling
            if (bullet.children.length > 0) {
                listItem.addClass('has-children');

                // Recursively render children if any
                this.renderNestedList(listItem, bullet.children);
            }
        });
    }

    /**
     * Navigates to another card
     * @param delta The direction to navigate (-1 for previous, 1 for next)
     */
    navigateToCard(delta: number) {
        if (this.cards.length === 0) return;

        // Calculate the new index
        let newIndex = this.currentCardIndex + delta;

        // Wrap around if needed
        if (newIndex < 0) {
            newIndex = this.cards.length - 1;
        } else if (newIndex >= this.cards.length) {
            newIndex = 0;
        }

        this.currentCardIndex = newIndex;
        this.render();
    }

    /**
     * Navigates to a specific card by index
     * @param index The index of the card to navigate to
     */
    navigateToSpecificCard(index: number) {
        if (this.cards.length === 0) return;

        // Ensure the index is valid
        if (index < 0) {
            index = 0;
        } else if (index >= this.cards.length) {
            index = this.cards.length - 1;
        }

        console.log(`Navigating to card ${index + 1}/${this.cards.length}: "${this.cards[index].text.substring(0, 30)}..."`);
        this.currentCardIndex = index;
        this.render();
    }

    /**
     * Opens the editor to edit the card content
     * @param card The card to edit
     */
    editCardContent(card: BulletPoint) {
        if (!this.activeEditor) return;

        const editor = this.activeEditor.editor;

        // Set the cursor to the start of the card content
        const startPos: EditorPosition = {
            line: card.lineStart,
            ch: 0
        };
        const endPos: EditorPosition = {
            line: card.lineEnd,
            ch: editor.getLine(card.lineEnd).length
        };

        // Select the card content and focus the editor
        editor.setSelection(startPos, endPos);
        editor.scrollIntoView({ from: startPos, to: endPos }, true);
        this.activeEditor.leaf.view.setEphemeralState({ focus: true });
    }

    // ItemView required methods
    getViewType(): string {
        return 'outliner-card-view';
    }

    getDisplayText(): string {
        return 'Outliner Card View';
    }

    async onOpen() {
        // Add the escape key handler when the view is opened
        document.addEventListener('keydown', this.escapeHandler);
        this.render();
    }

    async onClose() {
        // Remove the escape key handler when the view is closed
        document.removeEventListener('keydown', this.escapeHandler);
        this.cardViewContent.empty();
    }

    /**
     * Process markdown formatting using the plugin's processor
     * @param text The text to process
     * @returns Processed HTML with formatting
     */
    processMarkdownFormatting(text: string): string {
        return this.plugin.processMarkdownFormatting(text);
    }

    /**
     * Helper method for rendering formatted bullet text
     * Used in renderNestedList to display formatted bullet points
     * @param listItem The list item element to add the text to
     * @param bulletText The bullet text to format
     */
    private renderFormattedBulletText(listItem: HTMLElement, bulletText: string) {
        // Add the bullet text with markdown formatting
        const textSpan = listItem.createEl('span', {
            cls: 'outliner-card-list-item-text'
        });

        // Process markdown formatting for bold, italic, etc.
        const processedText = this.processMarkdownFormatting(bulletText);
        textSpan.innerHTML = processedText;
    }

}

/**
 * The overlay card view that displays bullet points as cards directly over the editor
 */
class OverlayCardView {
    private plugin: OutlinerCardViewPlugin;
    private overlay: HTMLElement;
    private container: HTMLElement;
    private cards: BulletPoint[] = [];
    private currentCardIndex: number = 0;
    private activeEditor: MarkdownView | null = null;

    constructor(
        plugin: OutlinerCardViewPlugin,
        overlay: HTMLElement,
        container: HTMLElement,
        cards: BulletPoint[],
        editor: MarkdownView
    ) {
        this.plugin = plugin;
        this.overlay = overlay;
        this.container = container;
        this.cards = cards;
        this.activeEditor = editor;

        // Add close on escape key
        document.addEventListener('keydown', this.handleKeydown);

        // Add close on overlay background click (but not card click)
        this.overlay.addEventListener('click', (e) => {
            if (e.target === this.overlay) {
                this.close();
            }
        });

        // Add close button
        const closeButton = this.container.createEl('button', {
            cls: 'outliner-card-close-button',
            text: 'X'
        });
        closeButton.addEventListener('click', () => this.close());
    }

    /**
     * Handle keyboard events
     */
    private handleKeydown = (evt: KeyboardEvent) => {
        if (evt.key === 'Escape') {
            this.close();
        } else if (evt.key === 'ArrowLeft' && evt.altKey) {
            this.navigateToCard(-1);
            evt.preventDefault();
        } else if (evt.key === 'ArrowRight' && evt.altKey) {
            this.navigateToCard(1);
            evt.preventDefault();
        }
    }

    /**
     * Close the overlay and clean up
     */
    close() {
        document.removeEventListener('keydown', this.handleKeydown);
        this.overlay.remove();

        // Clear the references in the plugin
        if (this.plugin.currentOverlay === this.overlay) {
            this.plugin.currentOverlay = null;
            this.plugin.currentCardView = null;
        }
    }

    /**
     * Renders the card view
     */
    render() {
        this.container.empty();

        // Create the card navigation UI
        this.createNavigationUI();

        // Display the current card
        this.displayCard();

        // Add transition animations if enabled
        if (this.plugin.settings.cardTransitionAnimation) {
            this.container.addClass('animate');
        }
    }

    /**
     * Creates the navigation UI for the cards
     */
    createNavigationUI() {
        const navigationContainer = this.container.createEl('div', {
            cls: 'outliner-card-navigation'
        });

        // Create indentation level controls
        const indentationControls = navigationContainer.createEl('div', {
            cls: 'outliner-card-indentation-controls'
        });

        indentationControls.createEl('span', {
            cls: 'outliner-card-indentation-label',
            text: 'Indentation Level: '
        });

        // Decrease indentation button
        const decreaseButton = indentationControls.createEl('button', {
            cls: 'outliner-card-indentation-button',
            text: 'âˆ’'
        });        decreaseButton.setAttribute('aria-label', 'Decrease indentation level');
        decreaseButton.addEventListener('click', () => {
            const currentLevel = this.plugin.settings.defaultIndentationLevel;
            if (currentLevel > 1) {
                const newLevel = currentLevel - 1;
                // Simply use the refreshWithNewIndentationLevel method which handles saving settings
                this.refreshWithNewIndentationLevel(newLevel);
            }
        });

        // Indentation level selector
        const indentSelector = indentationControls.createEl('select', {
            cls: 'outliner-card-indentation-selector'
        });

        // Add options for levels 1-5
        for (let i = 1; i <= 5; i++) {
            const option = indentSelector.createEl('option', {
                value: i.toString(),
                text: i.toString()
            });

            // Mark the current level as selected
            if (i === this.plugin.settings.defaultIndentationLevel) {
                option.selected = true;
            }
        }

        // Increase indentation button
        const increaseButton = indentationControls.createEl('button', {
            cls: 'outliner-card-indentation-button',
            text: '+'
        });        increaseButton.setAttribute('aria-label', 'Increase indentation level');
        increaseButton.addEventListener('click', () => {
            const currentLevel = this.plugin.settings.defaultIndentationLevel;
            if (currentLevel < 5) {
                const newLevel = currentLevel + 1;
                // Simply use the refreshWithNewIndentationLevel method which handles saving settings
                this.refreshWithNewIndentationLevel(newLevel);
            }
        });

        // Handle indentation level change
        indentSelector.addEventListener('change', (e) => {
            const target = e.target as HTMLSelectElement;
            const level = parseInt(target.value);

            // Try to update to the new level
            this.refreshWithNewIndentationLevel(level);
        });

        // Add navigation info
        navigationContainer.createEl('div', {
            cls: 'outliner-card-navigation-info',
            text: `Card ${this.currentCardIndex + 1} of ${this.cards.length}`
        });

        // Add navigation buttons
        const buttonContainer = navigationContainer.createEl('div', {
            cls: 'outliner-card-navigation-buttons'
        });

        // Home/First card button
        const homeButton = buttonContainer.createEl('button', {
            cls: 'outliner-card-navigation-button outliner-card-navigation-home',
            text: 'â®ï¸ First'
        });
        homeButton.addEventListener('click', () => this.navigateToSpecificCard(0));

        // Previous button
        const prevButton = buttonContainer.createEl('button', {
            cls: 'outliner-card-navigation-button',
            text: 'â¬…ï¸ Previous'
        });
        prevButton.addEventListener('click', () => this.navigateToCard(-1));

        // Card selector dropdown
        const selectorContainer = buttonContainer.createEl('div', {
            cls: 'outliner-card-selector-container'
        });

        const selector = selectorContainer.createEl('select', {
            cls: 'outliner-card-selector'
        });

        // Add options for each card
        this.cards.forEach((card, index) => {
            const option = selector.createEl('option', {
                value: index.toString()
            });

            // Create a temporary div to process markdown and get plain text
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = this.processMarkdownFormatting(card.text);
            // Get text content strips HTML tags but preserves emojis
            option.text = tempDiv.textContent || card.text;

            if (index === this.currentCardIndex) {
                option.selected = true;
            }
        });

        selector.addEventListener('change', (e) => {
            const target = e.target as HTMLSelectElement;
            const index = parseInt(target.value);
            this.currentCardIndex = index;
            this.render();
        });

        // Next button
        const nextButton = buttonContainer.createEl('button', {
            cls: 'outliner-card-navigation-button',
            text: 'Next âž¡ï¸'
        });
        nextButton.addEventListener('click', () => this.navigateToCard(1));

        // Last card button
        const lastButton = buttonContainer.createEl('button', {
            cls: 'outliner-card-navigation-button outliner-card-navigation-last',
            text: 'Last â­ï¸'
        });
        lastButton.addEventListener('click', () => this.navigateToSpecificCard(this.cards.length - 1));
    }

    /**
     * Displays the current card
     */
    displayCard() {
        const currentCard = this.cards[this.currentCardIndex];
        if (!currentCard) return;

        const contentContainer = this.container.createEl('div', {
            cls: 'outliner-card-content-container'
        });

        // Create card title
        if (this.plugin.settings.showCardTitle) {
            const cardTitle = contentContainer.createEl('div', {
                cls: 'outliner-card-title'
            });
            // Add formatted title text
            cardTitle.innerHTML = this.processMarkdownFormatting(currentCard.text);
        }

        // Create card content
        const cardContent = contentContainer.createEl('div', {
            cls: 'outliner-card-content'
        });

        // Display the card's children as a nested list
        this.renderNestedList(cardContent, currentCard.children);

        // Add edit button if editing is allowed
        if (this.plugin.settings.allowEditing && this.activeEditor) {
            const editButton = contentContainer.createEl('button', {
                cls: 'outliner-card-edit-button',
                text: 'Edit Card Content'
            });

            editButton.addEventListener('click', () => this.editCardContent(currentCard));
        }

        // Add action buttons container at the bottom
        const actionButtons = this.container.createEl('div', {
            cls: 'outliner-card-action-buttons'
        });

        // Close button at the bottom
        const closeButton = actionButtons.createEl('button', {
            cls: 'outliner-card-action-button',
            text: 'Close'
        });
        closeButton.addEventListener('click', () => this.close());
    }

    /**
     * Renders a nested list of bullet points
     * @param container The container element to add the list to
     * @param bullets The bullet points to render
     */
    renderNestedList(container: HTMLElement, bullets: BulletPoint[]) {
        if (bullets.length === 0) {
            container.createEl('div', {
                cls: 'outliner-card-empty-content',
                text: 'No content'
            });
            return;
        }

        const list = container.createEl('ul', {
            cls: 'outliner-card-list'
        });

        // Render each bullet point
        bullets.forEach(bullet => {
            const listItem = list.createEl('li', {
                cls: 'outliner-card-list-item'
            });

            // Add the bullet text
            this.renderFormattedBulletText(listItem, bullet.text);

            // If there are children, add a class to the parent for styling
            if (bullet.children.length > 0) {
                listItem.addClass('has-children');

                // Recursively render children if any
                this.renderNestedList(listItem, bullet.children);
            }
        });
    }

    /**
     * Navigates to another card
     * @param delta The direction to navigate (-1 for previous, 1 for next)
     */
    navigateToCard(delta: number) {
        if (this.cards.length === 0) return;

        // Calculate the new index
        let newIndex = this.currentCardIndex + delta;

        // Wrap around if needed
        if (newIndex < 0) {
            newIndex = this.cards.length - 1;
        } else if (newIndex >= this.cards.length) {
            newIndex = 0;
        }

        this.currentCardIndex = newIndex;
        this.render();
    }

    /**
     * Navigates to a specific card by index
     * @param index The index of the card to navigate to
     */
    navigateToSpecificCard(index: number) {
        if (this.cards.length === 0) return;

        // Ensure the index is valid
        if (index < 0) {
            index = 0;
        } else if (index >= this.cards.length) {
            index = this.cards.length - 1;
        }

        console.log(`Navigating to card ${index + 1}/${this.cards.length}: "${this.cards[index].text.substring(0, 30)}..."`);
        this.currentCardIndex = index;
        this.render();
    }

    /**
     * Opens the editor to edit the card content
     * @param card The card to edit
     */
    editCardContent(card: BulletPoint) {
        if (!this.activeEditor) return;

        const editor = this.activeEditor.editor;

        // Set the cursor to the start of the card content
        const startPos: EditorPosition = {
            line: card.lineStart,
            ch: 0
        };
        const endPos: EditorPosition = {
            line: card.lineEnd,
            ch: editor.getLine(card.lineEnd).length
        };

        // Select the card content, focus the editor, and close the overlay
        editor.setSelection(startPos, endPos);
        editor.scrollIntoView({ from: startPos, to: endPos }, true);
        this.activeEditor.leaf.view.setEphemeralState({ focus: true });
        this.close();
    }

    /**
     * Process markdown formatting using the plugin's processor
     * @param text The text to process
     * @returns Processed HTML with formatting
     */
    processMarkdownFormatting(text: string): string {
        return this.plugin.processMarkdownFormatting(text);
    }

    /**
     * Helper method for rendering formatted bullet text
     * Used in renderNestedList to display formatted bullet points
     * @param listItem The list item element to add the text to
     * @param bulletText The bullet text to format
     */
    private renderFormattedBulletText(listItem: HTMLElement, bulletText: string) {
        // Add the bullet text with markdown formatting
        const textSpan = listItem.createEl('span', {
            cls: 'outliner-card-list-item-text'
        });

        // Process markdown formatting for bold, italic, etc.
        const processedText = this.processMarkdownFormatting(bulletText);
        textSpan.innerHTML = processedText;
    }

    /**
     * Refreshes the view with a new indentation level
     * @param level The new indentation level to use
     * @param resetIndex Whether to reset the card index to 0 (default: true)
     */
    refreshWithNewIndentationLevel(level: number, resetIndex: boolean = true) {
        if (!this.activeEditor) return;

        // Update the plugin settings once
        if (this.plugin.settings.defaultIndentationLevel !== level) {
            this.plugin.settings.defaultIndentationLevel = level;
            this.plugin.saveSettings();
        }

        // Parse the bullet points with the new level
        const content = this.activeEditor.editor.getValue();
        const bulletPoints = this.plugin.parseBulletPoints(content);
        const targetBullets = this.plugin.getBulletsAtLevel(bulletPoints, level);

        // Update the cards array
        this.cards = targetBullets;

        // Reset the index if specified
        if (resetIndex) {
            this.currentCardIndex = 0;
        } else if (this.currentCardIndex >= this.cards.length) {
            // If the current index is now out of bounds after changing levels,
            // set it to the last card
            this.currentCardIndex = Math.max(0, this.cards.length - 1);
        }

        // Re-render the view
        this.render();
    }
}

class OutlinerCardViewSettingTab extends PluginSettingTab {
    plugin: OutlinerCardViewPlugin;

    constructor(app: App, plugin: OutlinerCardViewPlugin) {
        super(app, plugin);
        this.plugin = plugin;
    }

    display(): void {
        const { containerEl } = this;

        // Clear the container element to prevent duplicate settings
        containerEl.empty();

        // Indentation level setting
        new Setting(containerEl)
            .setName('Default Indentation Level')
            .setDesc('Select which level of bullet points to display as cards (1 = top level)')
            .addSlider(slider => slider
                .setLimits(1, 5, 1)
                .setValue(this.plugin.settings.defaultIndentationLevel)
                .setDynamicTooltip()
                .onChange(async (value) => {
                    this.plugin.settings.defaultIndentationLevel = value;
                    await this.plugin.saveSettings();
                }));

        // Show card title setting
        new Setting(containerEl)
            .setName('Show Card Title')
            .setDesc('Show the bullet point text as the card title')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.showCardTitle)
                .onChange(async (value) => {
                    this.plugin.settings.showCardTitle = value;
                    await this.plugin.saveSettings();
                }));

        // Allow editing setting
        new Setting(containerEl)
            .setName('Allow Editing')
            .setDesc('Enable direct editing of card content')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.allowEditing)
                .onChange(async (value) => {
                    this.plugin.settings.allowEditing = value;
                    await this.plugin.saveSettings();
                }));

        // Card transition animation setting
        new Setting(containerEl)
            .setName('Card Transition Animation')
            .setDesc('Enable smooth transition animations between cards')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.cardTransitionAnimation)
                .onChange(async (value) => {
                    this.plugin.settings.cardTransitionAnimation = value;
                    await this.plugin.saveSettings();
                }));

        // Show hover buttons setting
        new Setting(containerEl)
            .setName('Show Hover Buttons')
            .setDesc('Show hover icons on bullet points for quick card view access')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.showHoverButtons)
                .onChange(async (value) => {
                    this.plugin.settings.showHoverButtons = value;
                    await this.plugin.saveSettings();
                }));

        // Hotkey settings section
        containerEl.createEl('h2', { text: 'Hotkeys' });

        // Toggle card view hotkey
        new Setting(containerEl)
            .setName('Toggle Card View Hotkey')
            .setDesc('Set the hotkey for toggling the card view')
            .addText(text => text
                .setValue('')
                .setPlaceholder('Example: Mod+Shift+O')
                .onChange(async (value) => {
                    this.plugin.settings.toggleCardViewHotkey = value.trim() !== '';
                    await this.plugin.saveSettings();
                }));

        // Next card hotkey
        new Setting(containerEl)
            .setName('Next Card Hotkey')
            .setDesc('Set the hotkey for showing the next card')
            .addText(text => text
                .setValue('')
                .setPlaceholder('Example: Alt+ArrowRight')
                .onChange(async (value) => {
                    this.plugin.settings.nextCardHotkey = value.trim() !== '';
                    await this.plugin.saveSettings();
                }));

        // Previous card hotkey
        new Setting(containerEl)
            .setName('Previous Card Hotkey')
            .setDesc('Set the hotkey for showing the previous card')
            .addText(text => text
                .setValue('')
                .setPlaceholder('Example: Alt+ArrowLeft')
                .onChange(async (value) => {
                    this.plugin.settings.previousCardHotkey = value.trim() !== '';
                    await this.plugin.saveSettings();
                }));
    }
}

