import { App, Plugin, PluginSettingTab, Setting, MarkdownView, Notice, Modal, TFile, WorkspaceLeaf, EditorPosition } from 'obsidian';

interface OutlinerCardViewSettings {
    defaultIndentationLevel: number;
    cardViewPosition: 'right' | 'left' | 'bottom';
    showCardTitle: boolean;
    allowEditing: boolean;
    showCardNavigation: boolean;
    cardTransitionAnimation: boolean;
}

const DEFAULT_SETTINGS: OutlinerCardViewSettings = {
    defaultIndentationLevel: 2,
    cardViewPosition: 'right',
    showCardTitle: true,
    allowEditing: true,
    showCardNavigation: true,
    cardTransitionAnimation: true
}

interface BulletPoint {
    text: string;
    level: number;
    children: BulletPoint[];
    lineStart: number;
    lineEnd: number;
}

export default class OutlinerCardViewPlugin extends Plugin {
    settings: OutlinerCardViewSettings;
    private cardView: CardView | null = null;
    private activeEditor: MarkdownView | null = null;
    private activeLeafChange: any = null;

    async onload() {
        await this.loadSettings();
        console.log('Loading Outliner Card View Plugin');

        // Register view type
        this.registerView(
            'outliner-card-view',
            (leaf) => (this.cardView = new CardView(leaf, this))
        );

        // Command to toggle card view
        this.addCommand({
            id: 'toggle-card-view',
            name: 'Toggle Card View',
            callback: () => this.toggleCardView(),
            hotkeys: [
                {
                    modifiers: ["Mod", "Shift"],
                    key: "O"
                }
            ]
        });

        // Command to show next card
        this.addCommand({
            id: 'next-card',
            name: 'Show Next Card',
            callback: () => {
                if (this.cardView) {
                    this.cardView.navigateToCard(1);
                } else {
                    new Notice('Card view is not active');
                }
            },
            hotkeys: [
                {
                    modifiers: ["Alt"],
                    key: "ArrowRight"
                }
            ]
        });

        // Command to show previous card
        this.addCommand({
            id: 'previous-card',
            name: 'Show Previous Card',
            callback: () => {
                if (this.cardView) {
                    this.cardView.navigateToCard(-1);
                } else {
                    new Notice('Card view is not active');
                }
            },
            hotkeys: [
                {
                    modifiers: ["Alt"],
                    key: "ArrowLeft"
                }
            ]
        });

        // Listen for changes in the active leaf
        this.activeLeafChange = this.app.workspace.on('active-leaf-change', (leaf) => {
            const view = leaf?.view;
            if (view instanceof MarkdownView) {
                this.activeEditor = view;
                // Update card view when the active editor changes
                if (this.cardView?.isVisible) {
                    this.updateCardView();
                }
            }
        });

        // Register event reference
        this.registerEvent(this.activeLeafChange);

        // Add settings tab
        this.addSettingTab(new OutlinerCardViewSettingTab(this.app, this));
    }

    onunload() {
        // Clean up view
        if (this.cardView) {
            this.app.workspace.detachLeavesOfType('outliner-card-view');
        }

        // Unregister event if exists
        if (this.activeLeafChange) {
            this.app.workspace.offref(this.activeLeafChange);
            this.activeLeafChange = null;
        }
    }

    /**
     * Toggles the card view panel
     */
    async toggleCardView() {
        const { workspace } = this.app;

        // Check if the view is already visible
        const leaves = workspace.getLeavesOfType('outliner-card-view');

        if (leaves.length > 0) {
            // If the view is open, close it
            leaves.forEach(leaf => leaf.detach());
            return;
        }

        // If not visible, create and display it
        const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
        if (!activeView) {
            new Notice('No active markdown view found.');
            return;
        }

        this.activeEditor = activeView;

        // Create a new leaf for the card view based on settings
        const direction = this.settings.cardViewPosition;
        const leaf = this.app.workspace.getRightLeaf(false);
        await leaf.setViewState({
            type: 'outliner-card-view',
            active: true,
        });

        // Reveal the leaf
        this.app.workspace.revealLeaf(leaf);

        // Update the card view with content from the active editor
        this.updateCardView();
    }

    /**
     * Updates the card view with content from the active editor
     */
    updateCardView() {
        if (!this.cardView || !this.activeEditor) return;

        const editor = this.activeEditor.editor;
        const content = editor.getValue();

        // Parse the bullet points from the content
        const bulletPoints = this.parseBulletPoints(content);

        // Find bullets at the target indentation level
        const targetLevel = this.settings.defaultIndentationLevel;
        const targetBullets = this.getBulletsAtLevel(bulletPoints, targetLevel);

        // Update the card view with the target bullets
        this.cardView.updateCards(targetBullets, this.activeEditor);
    }

    /**
     * Parses bullet points from markdown content
     * @param content The markdown content to parse
     * @returns An array of parsed bullet points
     */
    parseBulletPoints(content: string): BulletPoint[] {
        const lines = content.split('\n');
        const rootBullets: BulletPoint[] = [];
        const stack: BulletPoint[] = [];
        let currentLevel = 0;

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            // Check if this line is a bullet point (starts with -, *, or number followed by period)
            const bulletMatch = line.match(/^(\s*)(-|\*|\d+\.)\s(.*)$/);

            if (bulletMatch) {
                // Calculate indentation level based on leading whitespace
                const indent = bulletMatch[1];
                const level = Math.floor(indent.length / 2) + 1; // Convert spaces to level (2 spaces = 1 level)
                const text = bulletMatch[3].trim();

                const bulletPoint: BulletPoint = {
                    text,
                    level,
                    children: [],
                    lineStart: i,
                    lineEnd: i
                };

                // If it's a sub-bullet of the current bullet
                if (level > currentLevel) {
                    if (stack.length > 0) {
                        // Add as child to the last item in stack
                        stack[stack.length - 1].children.push(bulletPoint);
                    } else {
                        // No parent, add to root
                        rootBullets.push(bulletPoint);
                    }
                    stack.push(bulletPoint);
                }
                // If it's a sibling or higher up in the hierarchy
                else {
                    // Pop from stack until we find the right level
                    while (stack.length > 0 && stack[stack.length - 1].level >= level) {
                        stack.pop();
                    }

                    if (stack.length > 0) {
                        // Add as child to the current stack top
                        stack[stack.length - 1].children.push(bulletPoint);
                    } else {
                        // Add to root if no parent
                        rootBullets.push(bulletPoint);
                    }
                    stack.push(bulletPoint);
                }

                currentLevel = level;
            }
            // If not a bullet but a continuation of the current bullet
            else if (stack.length > 0 && line.trim() !== '') {
                // Update the end line of the current bullet
                stack[stack.length - 1].lineEnd = i;
            }
        }

        return rootBullets;
    }

    /**
     * Gets all bullet points at a specific indentation level
     * @param bullets The array of bullet points to search
     * @param targetLevel The target indentation level
     * @returns An array of bullet points at the target level
     */
    getBulletsAtLevel(bullets: BulletPoint[], targetLevel: number): BulletPoint[] {
        const result: BulletPoint[] = [];

        // Recursive function to search through the bullet hierarchy
        const findBulletsAtLevel = (bullet: BulletPoint, currentLevel: number) => {
            if (bullet.level === targetLevel) {
                result.push(bullet);
            } else if (bullet.level < targetLevel) {
                // Continue searching in children
                bullet.children.forEach(child => findBulletsAtLevel(child, currentLevel + 1));
            }
        };

        // Start search from each root bullet
        bullets.forEach(bullet => findBulletsAtLevel(bullet, 1));

        return result;
    }

    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    }

    async saveSettings() {
        await this.saveData(this.settings);
    }
}

/**
 * The card view that displays bullet points as cards
 */
class CardView {
    private containerEl: HTMLElement;
    private plugin: OutlinerCardViewPlugin;
    private cards: BulletPoint[] = [];
    private currentCardIndex: number = 0;
    private activeEditor: MarkdownView | null = null;
    public isVisible: boolean = false;

    constructor(public leaf: WorkspaceLeaf, plugin: OutlinerCardViewPlugin) {
        this.plugin = plugin;
        this.containerEl = leaf.containerEl;
        this.isVisible = true;
    }

    /**
     * Updates the view with new cards
     * @param cards The bullet points to display as cards
     * @param editor The active editor view
     */
    updateCards(cards: BulletPoint[], editor: MarkdownView) {
        this.cards = cards;
        this.activeEditor = editor;
        this.currentCardIndex = 0;
        this.render();
    }

    /**
     * Renders the card view
     */
    render() {
        const contentEl = this.containerEl.querySelector('.view-content');
        if (!contentEl) return;

        contentEl.empty();

        if (this.cards.length === 0) {
            contentEl.createEl('div', {
                cls: 'outliner-card-empty-state',
                text: 'No bullet points found at the selected indentation level.'
            });
            return;
        }

        // Create the card navigation UI
        this.createNavigationUI(contentEl);

        // Create the card container
        const cardContainer = contentEl.createEl('div', {
            cls: 'outliner-card-container'
        });

        // Display the current card
        this.displayCard(cardContainer);
    }

    /**
     * Creates the navigation UI for the cards
     * @param contentEl The content element to add the navigation UI to
     */
    createNavigationUI(contentEl: HTMLElement) {
        const navigationContainer = contentEl.createEl('div', {
            cls: 'outliner-card-navigation'
        });

        // Add navigation info
        const navInfo = navigationContainer.createEl('div', {
            cls: 'outliner-card-navigation-info',
            text: `Card ${this.currentCardIndex + 1} of ${this.cards.length}`
        });

        // Add navigation buttons
        const buttonContainer = navigationContainer.createEl('div', {
            cls: 'outliner-card-navigation-buttons'
        });

        // Previous button
        const prevButton = buttonContainer.createEl('button', {
            cls: 'outliner-card-navigation-button',
            text: '⬅️ Previous'
        });
        prevButton.addEventListener('click', () => this.navigateToCard(-1));

        // Card selector dropdown
        const selectorContainer = buttonContainer.createEl('div', {
            cls: 'outliner-card-selector-container'
        });

        const selector = selectorContainer.createEl('select', {
            cls: 'outliner-card-selector'
        });

        // Add options for each card
        this.cards.forEach((card, index) => {
            const option = selector.createEl('option', {
                value: index.toString(),
                text: card.text
            });

            if (index === this.currentCardIndex) {
                option.selected = true;
            }
        });

        selector.addEventListener('change', (e) => {
            const target = e.target as HTMLSelectElement;
            const index = parseInt(target.value);
            this.currentCardIndex = index;
            this.render();
        });

        // Next button
        const nextButton = buttonContainer.createEl('button', {
            cls: 'outliner-card-navigation-button',
            text: 'Next ➡️'
        });
        nextButton.addEventListener('click', () => this.navigateToCard(1));
    }

    /**
     * Displays the current card
     * @param container The container element to add the card to
     */
    displayCard(container: HTMLElement) {
        const currentCard = this.cards[this.currentCardIndex];
        if (!currentCard) return;

        // Create card title
        const cardTitle = container.createEl('div', {
            cls: 'outliner-card-title',
            text: currentCard.text
        });

        // Create card content
        const cardContent = container.createEl('div', {
            cls: 'outliner-card-content'
        });

        // Display the card's children as a nested list
        this.renderNestedList(cardContent, currentCard.children);

        // Add edit button if editing is allowed
        if (this.plugin.settings.allowEditing && this.activeEditor) {
            const editButton = container.createEl('button', {
                cls: 'outliner-card-edit-button',
                text: 'Edit Card Content'
            });

            editButton.addEventListener('click', () => this.editCardContent(currentCard));
        }
    }

    /**
     * Renders a nested list of bullet points
     * @param container The container element to add the list to
     * @param bullets The bullet points to render
     */
    renderNestedList(container: HTMLElement, bullets: BulletPoint[]) {
        if (bullets.length === 0) {
            container.createEl('div', {
                cls: 'outliner-card-empty-content',
                text: 'No content'
            });
            return;
        }

        const list = container.createEl('ul', {
            cls: 'outliner-card-list'
        });

        // Render each bullet point
        bullets.forEach(bullet => {
            const listItem = list.createEl('li', {
                cls: 'outliner-card-list-item'
            });

            // Add the bullet text
            listItem.createEl('span', {
                cls: 'outliner-card-list-item-text',
                text: bullet.text
            });

            // Recursively render children if any
            if (bullet.children.length > 0) {
                this.renderNestedList(listItem, bullet.children);
            }
        });
    }

    /**
     * Navigates to another card
     * @param delta The direction to navigate (-1 for previous, 1 for next)
     */
    navigateToCard(delta: number) {
        if (this.cards.length === 0) return;

        // Calculate the new index
        let newIndex = this.currentCardIndex + delta;

        // Wrap around if needed
        if (newIndex < 0) {
            newIndex = this.cards.length - 1;
        } else if (newIndex >= this.cards.length) {
            newIndex = 0;
        }

        this.currentCardIndex = newIndex;
        this.render();
    }

    /**
     * Opens the editor to edit the card content
     * @param card The card to edit
     */
    editCardContent(card: BulletPoint) {
        if (!this.activeEditor) return;

        const editor = this.activeEditor.editor;

        // Set the cursor to the start of the card content
        const startPos: EditorPosition = {
            line: card.lineStart,
            ch: 0
        };
        const endPos: EditorPosition = {
            line: card.lineEnd,
            ch: editor.getLine(card.lineEnd).length
        };

        // Select the card content and focus the editor
        editor.setSelection(startPos, endPos);
        editor.scrollIntoView({ from: startPos, to: endPos }, true);
        this.activeEditor.leaf.view.setEphemeralState({ focus: true });
    }

    // Required methods for a view
    getViewType(): string {
        return 'outliner-card-view';
    }

    getDisplayText(): string {
        return 'Outliner Card View';
    }

    async onOpen() {
        this.isVisible = true;
        this.render();
    }

    async onClose() {
        this.isVisible = false;
    }
}

class OutlinerCardViewSettingTab extends PluginSettingTab {
    plugin: OutlinerCardViewPlugin;

    constructor(app: App, plugin: OutlinerCardViewPlugin) {
        super(app, plugin);
        this.plugin = plugin;
    }

    display(): void {
        const { containerEl } = this;
        containerEl.empty();

        containerEl.createEl('h2', { text: 'Outliner Card View Settings' });

        // Indentation level setting
        new Setting(containerEl)
            .setName('Default Indentation Level')
            .setDesc('Select which level of bullet points to display as cards (1 = top level)')
            .addSlider(slider => slider
                .setLimits(1, 5, 1)
                .setValue(this.plugin.settings.defaultIndentationLevel)
                .setDynamicTooltip()
                .onChange(async (value) => {
                    this.plugin.settings.defaultIndentationLevel = value;
                    await this.plugin.saveSettings();
                }));

        // Card view position setting
        new Setting(containerEl)
            .setName('Card View Position')
            .setDesc('Choose where to display the card view panel')
            .addDropdown(dropdown => dropdown
                .addOption('right', 'Right Side')
                .addOption('left', 'Left Side')
                .addOption('bottom', 'Bottom')
                .setValue(this.plugin.settings.cardViewPosition)
                .onChange(async (value: 'right' | 'left' | 'bottom') => {
                    this.plugin.settings.cardViewPosition = value;
                    await this.plugin.saveSettings();
                }));

        // Show card title setting
        new Setting(containerEl)
            .setName('Show Card Title')
            .setDesc('Show the bullet point text as the card title')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.showCardTitle)
                .onChange(async (value) => {
                    this.plugin.settings.showCardTitle = value;
                    await this.plugin.saveSettings();
                }));

        // Allow editing setting
        new Setting(containerEl)
            .setName('Allow Editing')
            .setDesc('Enable direct editing of card content')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.allowEditing)
                .onChange(async (value) => {
                    this.plugin.settings.allowEditing = value;
                    await this.plugin.saveSettings();
                }));

        // Show card navigation setting
        new Setting(containerEl)
            .setName('Show Card Navigation')
            .setDesc('Show navigation controls for moving between cards')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.showCardNavigation)
                .onChange(async (value) => {
                    this.plugin.settings.showCardNavigation = value;
                    await this.plugin.saveSettings();
                }));

        // Card transition animation setting
        new Setting(containerEl)
            .setName('Card Transition Animation')
            .setDesc('Enable smooth transition animations between cards')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.cardTransitionAnimation)
                .onChange(async (value) => {
                    this.plugin.settings.cardTransitionAnimation = value;
                    await this.plugin.saveSettings();
                }));
    }
}
